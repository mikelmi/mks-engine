{"version":3,"sources":["angular-ui-tree.js","dashboard.js","menu-manager.js","mks-admin-ext.js","widget-manager.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"admin.js","sourcesContent":["/**\n * @license Angular UI Tree v2.17.0\n * (c) 2010-2016. https://github.com/angular-ui-tree/angular-ui-tree\n * License: MIT\n */\n(function () {\n  'use strict';\n\n  angular.module('ui.tree', [])\n    .constant('treeConfig', {\n      treeClass: 'angular-ui-tree',\n      emptyTreeClass: 'angular-ui-tree-empty',\n      hiddenClass: 'angular-ui-tree-hidden',\n      nodesClass: 'angular-ui-tree-nodes',\n      nodeClass: 'angular-ui-tree-node',\n      handleClass: 'angular-ui-tree-handle',\n      placeholderClass: 'angular-ui-tree-placeholder',\n      dragClass: 'angular-ui-tree-drag',\n      dragThreshold: 3,\n      levelThreshold: 30,\n      defaultCollapsed: false\n    });\n\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n    .controller('TreeHandleController', ['$scope', '$element',\n      function ($scope, $element) {\n        this.scope = $scope;\n\n        $scope.$element = $element;\n        $scope.$nodeScope = null;\n        $scope.$type = 'uiTreeHandle';\n\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n    .controller('TreeNodeController', ['$scope', '$element',\n      function ($scope, $element) {\n        this.scope = $scope;\n\n        $scope.$element = $element;\n        $scope.$modelValue = null; // Model value for node;\n        $scope.$parentNodeScope = null; // uiTreeNode Scope of parent node;\n        $scope.$childNodesScope = null; // uiTreeNodes Scope of child nodes.\n        $scope.$parentNodesScope = null; // uiTreeNodes Scope of parent nodes.\n        $scope.$treeScope = null; // uiTree scope\n        $scope.$handleScope = null; // it's handle scope\n        $scope.$type = 'uiTreeNode';\n        $scope.$$allowNodeDrop = false;\n        $scope.collapsed = false;\n        $scope.expandOnHover = false;\n\n        $scope.init = function (controllersArr) {\n          var treeNodesCtrl = controllersArr[0];\n          $scope.$treeScope = controllersArr[1] ? controllersArr[1].scope : null;\n\n          // find the scope of it's parent node\n          $scope.$parentNodeScope = treeNodesCtrl.scope.$nodeScope;\n          // modelValue for current node\n          $scope.$modelValue = treeNodesCtrl.scope.$modelValue[$scope.$index];\n          $scope.$parentNodesScope = treeNodesCtrl.scope;\n          treeNodesCtrl.scope.initSubNode($scope); // init sub nodes\n\n          $element.on('$destroy', function () {\n            treeNodesCtrl.scope.destroySubNode($scope); // destroy sub nodes\n          });\n        };\n\n        $scope.index = function () {\n          return $scope.$parentNodesScope.$modelValue.indexOf($scope.$modelValue);\n        };\n\n        $scope.dragEnabled = function () {\n          return !($scope.$treeScope && !$scope.$treeScope.dragEnabled);\n        };\n\n        $scope.isSibling = function (targetNode) {\n          return $scope.$parentNodesScope == targetNode.$parentNodesScope;\n        };\n\n        $scope.isChild = function (targetNode) {\n          var nodes = $scope.childNodes();\n          return nodes && nodes.indexOf(targetNode) > -1;\n        };\n\n        $scope.prev = function () {\n          var index = $scope.index();\n          if (index > 0) {\n            return $scope.siblings()[index - 1];\n          }\n          return null;\n        };\n\n        $scope.siblings = function () {\n          return $scope.$parentNodesScope.childNodes();\n        };\n\n        $scope.childNodesCount = function () {\n          return $scope.childNodes() ? $scope.childNodes().length : 0;\n        };\n\n        $scope.hasChild = function () {\n          return $scope.childNodesCount() > 0;\n        };\n\n        $scope.childNodes = function () {\n          return $scope.$childNodesScope && $scope.$childNodesScope.$modelValue ?\n            $scope.$childNodesScope.childNodes() :\n            null;\n        };\n\n        $scope.accept = function (sourceNode, destIndex) {\n          return $scope.$childNodesScope &&\n            $scope.$childNodesScope.$modelValue &&\n            $scope.$childNodesScope.accept(sourceNode, destIndex);\n        };\n\n        $scope.remove = function () {\n          return $scope.$parentNodesScope.removeNode($scope);\n        };\n\n        $scope.toggle = function () {\n          $scope.collapsed = !$scope.collapsed;\n          $scope.$treeScope.$callbacks.toggle($scope.collapsed, $scope);\n        };\n\n        $scope.collapse = function () {\n          $scope.collapsed = true;\n        };\n\n        $scope.expand = function () {\n          $scope.collapsed = false;\n        };\n\n        $scope.depth = function () {\n          var parentNode = $scope.$parentNodeScope;\n          if (parentNode) {\n            return parentNode.depth() + 1;\n          }\n          return 1;\n        };\n\n        /**\n        * Returns the depth of the deepest subtree under this node\n        * @param scope a TreeNodesController scope object\n        * @returns Depth of all nodes *beneath* this node. If scope belongs to a leaf node, the\n        *   result is 0 (it has no subtree).\n        */\n        function countSubTreeDepth(scope) {\n          var thisLevelDepth = 0,\n              childNodes = scope.childNodes(),\n              childNode,\n              childDepth,\n              i;\n          if (!childNodes || childNodes.length === 0) {\n            return 0;\n          }\n          for (i = childNodes.length - 1; i >= 0 ; i--) {\n            childNode = childNodes[i],\n            childDepth = 1 + countSubTreeDepth(childNode);\n            thisLevelDepth = Math.max(thisLevelDepth, childDepth);\n          }\n          return thisLevelDepth;\n        }\n\n        $scope.maxSubDepth = function () {\n          return $scope.$childNodesScope ? countSubTreeDepth($scope.$childNodesScope) : 0;\n        };\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n    .controller('TreeNodesController', ['$scope', '$element',\n      function ($scope, $element) {\n        this.scope = $scope;\n\n        $scope.$element = $element;\n        $scope.$modelValue = null;\n        $scope.$nodeScope = null; // the scope of node which the nodes belongs to\n        $scope.$treeScope = null;\n        $scope.$type = 'uiTreeNodes';\n        $scope.$nodesMap = {};\n\n        $scope.nodropEnabled = false;\n        $scope.maxDepth = 0;\n        $scope.cloneEnabled = false;\n\n        $scope.initSubNode = function (subNode) {\n          if (!subNode.$modelValue) {\n            return null;\n          }\n          $scope.$nodesMap[subNode.$modelValue.$$hashKey] = subNode;\n        };\n\n        $scope.destroySubNode = function (subNode) {\n          if (!subNode.$modelValue) {\n            return null;\n          }\n          $scope.$nodesMap[subNode.$modelValue.$$hashKey] = null;\n        };\n\n        $scope.accept = function (sourceNode, destIndex) {\n          return $scope.$treeScope.$callbacks.accept(sourceNode, $scope, destIndex);\n        };\n\n        $scope.beforeDrag = function (sourceNode) {\n          return $scope.$treeScope.$callbacks.beforeDrag(sourceNode);\n        };\n\n        $scope.isParent = function (node) {\n          return node.$parentNodesScope == $scope;\n        };\n\n        $scope.hasChild = function () {\n          return $scope.$modelValue.length > 0;\n        };\n\n        $scope.safeApply = function (fn) {\n          var phase = this.$root.$$phase;\n          if (phase == '$apply' || phase == '$digest') {\n            if (fn && (typeof (fn) === 'function')) {\n              fn();\n            }\n          } else {\n            this.$apply(fn);\n          }\n        };\n\n        $scope.removeNode = function (node) {\n          var index = $scope.$modelValue.indexOf(node.$modelValue);\n          if (index > -1) {\n            $scope.safeApply(function () {\n              $scope.$modelValue.splice(index, 1)[0];\n            });\n            return $scope.$treeScope.$callbacks.removed(node);\n          }\n          return null;\n        };\n\n        $scope.insertNode = function (index, nodeData) {\n          $scope.safeApply(function () {\n            $scope.$modelValue.splice(index, 0, nodeData);\n          });\n        };\n\n        $scope.childNodes = function () {\n          var i, nodes = [];\n          if ($scope.$modelValue) {\n            for (i = 0; i < $scope.$modelValue.length; i++) {\n              nodes.push($scope.$nodesMap[$scope.$modelValue[i].$$hashKey]);\n            }\n          }\n          return nodes;\n        };\n\n        $scope.depth = function () {\n          if ($scope.$nodeScope) {\n            return $scope.$nodeScope.depth();\n          }\n          return 0; // if it has no $nodeScope, it's root\n        };\n\n        // check if depth limit has reached\n        $scope.outOfDepth = function (sourceNode) {\n          var maxDepth = $scope.maxDepth || $scope.$treeScope.maxDepth;\n          if (maxDepth > 0) {\n            return $scope.depth() + sourceNode.maxSubDepth() + 1 > maxDepth;\n          }\n          return false;\n        };\n\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n    .controller('TreeController', ['$scope', '$element',\n      function ($scope, $element) {\n        this.scope = $scope;\n\n        $scope.$element = $element;\n        $scope.$nodesScope = null; // root nodes\n        $scope.$type = 'uiTree';\n        $scope.$emptyElm = null;\n        $scope.$callbacks = null;\n\n        $scope.dragEnabled = true;\n        $scope.emptyPlaceholderEnabled = true;\n        $scope.maxDepth = 0;\n        $scope.dragDelay = 0;\n        $scope.cloneEnabled = false;\n        $scope.nodropEnabled = false;\n\n        // Check if it's a empty tree\n        $scope.isEmpty = function () {\n          return ($scope.$nodesScope && $scope.$nodesScope.$modelValue\n          && $scope.$nodesScope.$modelValue.length === 0);\n        };\n\n        // add placeholder to empty tree\n        $scope.place = function (placeElm) {\n          $scope.$nodesScope.$element.append(placeElm);\n          $scope.$emptyElm.remove();\n        };\n\n        this.resetEmptyElement = function () {\n          if ((!$scope.$nodesScope.$modelValue || $scope.$nodesScope.$modelValue.length === 0) &&\n            $scope.emptyPlaceholderEnabled) {\n            $element.append($scope.$emptyElm);\n          } else {\n            $scope.$emptyElm.remove();\n          }\n        };\n\n        $scope.resetEmptyElement = this.resetEmptyElement;\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n    .directive('uiTree', ['treeConfig', '$window',\n      function (treeConfig, $window) {\n        return {\n          restrict: 'A',\n          scope: true,\n          controller: 'TreeController',\n          link: function (scope, element, attrs, ctrl) {\n            var callbacks = {\n              accept: null,\n              beforeDrag: null\n            },\n              config = {},\n              tdElm,\n              $trElm,\n              emptyElmColspan;\n\n            angular.extend(config, treeConfig);\n            if (config.treeClass) {\n              element.addClass(config.treeClass);\n            }\n\n            if (element.prop('tagName').toLowerCase() === 'table') {\n              scope.$emptyElm = angular.element($window.document.createElement('tr'));\n              $trElm = element.find('tr');\n              // If we can find a tr, then we can use its td children as the empty element colspan.\n              if ($trElm.length > 0) {\n                emptyElmColspan = angular.element($trElm).children().length;\n              } else {\n                // If not, by setting a huge colspan we make sure it takes full width.\n                emptyElmColspan = 1000000;\n              }\n              tdElm = angular.element($window.document.createElement('td'))\n                .attr('colspan', emptyElmColspan);\n              scope.$emptyElm.append(tdElm);\n            } else {\n              scope.$emptyElm = angular.element($window.document.createElement('div'));\n            }\n\n            if (config.emptyTreeClass) {\n              scope.$emptyElm.addClass(config.emptyTreeClass);\n            }\n\n            scope.$watch('$nodesScope.$modelValue.length', function (val) {\n              if (!angular.isNumber(val)) {\n                return;\n              }\n\n              ctrl.resetEmptyElement();\n            }, true);\n\n            scope.$watch(attrs.dragEnabled, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.dragEnabled = val;\n              }\n            });\n\n            scope.$watch(attrs.emptyPlaceholderEnabled, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.emptyPlaceholderEnabled = val;\n                ctrl.resetEmptyElement();\n              }\n            });\n\n            scope.$watch(attrs.nodropEnabled, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.nodropEnabled = val;\n              }\n            });\n\n            scope.$watch(attrs.cloneEnabled, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.cloneEnabled = val;\n              }\n            });\n\n            scope.$watch(attrs.maxDepth, function (val) {\n              if ((typeof val) == 'number') {\n                scope.maxDepth = val;\n              }\n            });\n\n            scope.$watch(attrs.dragDelay, function (val) {\n              if ((typeof val) == 'number') {\n                scope.dragDelay = val;\n              }\n            });\n\n            /**\n             * Callback checks if the destination node can accept the dragged node.\n             * By default, ui-tree will check that 'data-nodrop-enabled' is not set for the\n             * destination ui-tree-nodes, and that the 'max-depth' attribute will not be exceeded\n             * if it is set on the ui-tree or ui-tree-nodes.\n             * This callback can be overridden, but callers must manually enforce nodrop and max-depth\n             * themselves if they need those to be enforced.\n             * @param sourceNodeScope Scope of the ui-tree-node being dragged\n             * @param destNodesScope Scope of the ui-tree-nodes where the node is hovering\n             * @param destIndex Index in the destination nodes array where the source node will drop\n             * @returns {boolean} True if the node is permitted to be dropped here\n             */\n            callbacks.accept = function (sourceNodeScope, destNodesScope, destIndex) {\n              return !(destNodesScope.nodropEnabled || destNodesScope.$treeScope.nodropEnabled || destNodesScope.outOfDepth(sourceNodeScope));\n            };\n\n            callbacks.beforeDrag = function (sourceNodeScope) {\n              return true;\n            };\n\n            callbacks.expandTimeoutStart = function()\n            {\n\n            };\n\n            callbacks.expandTimeoutCancel = function()\n            {\n\n            };\n\n            callbacks.expandTimeoutEnd = function()\n            {\n\n            };\n\n            callbacks.removed = function (node) {\n\n            };\n\n            /**\n             * Callback is fired when a node is successfully dropped in a new location\n             * @param event\n             */\n            callbacks.dropped = function (event) {\n\n            };\n\n            /**\n             * Callback is fired each time the user starts dragging a node\n             * @param event\n             */\n            callbacks.dragStart = function (event) {\n\n            };\n\n            /**\n             * Callback is fired each time a dragged node is moved with the mouse/touch.\n             * @param event\n             */\n            callbacks.dragMove = function (event) {\n\n            };\n\n            /**\n             * Callback is fired when the tree exits drag mode. If the user dropped a node, the drop may have been\n             * accepted or reverted.\n             * @param event\n             */\n            callbacks.dragStop = function (event) {\n\n            };\n\n            /**\n             * Callback is fired when a user drops a node (but prior to processing the drop action)\n             * beforeDrop can return a Promise, truthy, or falsy (returning nothing is falsy).\n             * If it returns falsy, or a resolve Promise, the node move is accepted\n             * If it returns truthy, or a rejected Promise, the node move is reverted\n             * @param event\n             * @returns {Boolean|Promise} Truthy (or rejected Promise) to cancel node move; falsy (or resolved promise)\n             */\n            callbacks.beforeDrop = function (event) {\n\n            };\n\n            /**\n             * Callback is fired when a user toggles node (but after processing the toggle action)\n             * @param sourceNodeScope\n             * @param collapsed\n             */\n            callbacks.toggle = function (collapsed, sourceNodeScope) {\n\n            };\n\n            scope.$watch(attrs.uiTree, function (newVal, oldVal) {\n              angular.forEach(newVal, function (value, key) {\n                if (callbacks[key]) {\n                  if (typeof value === 'function') {\n                    callbacks[key] = value;\n                  }\n                }\n              });\n\n              scope.$callbacks = callbacks;\n            }, true);\n\n\n          }\n        };\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n    .directive('uiTreeHandle', ['treeConfig',\n      function (treeConfig) {\n        return {\n          require: '^uiTreeNode',\n          restrict: 'A',\n          scope: true,\n          controller: 'TreeHandleController',\n          link: function (scope, element, attrs, treeNodeCtrl) {\n            var config = {};\n            angular.extend(config, treeConfig);\n            if (config.handleClass) {\n              element.addClass(config.handleClass);\n            }\n            // connect with the tree node.\n            if (scope != treeNodeCtrl.scope) {\n              scope.$nodeScope = treeNodeCtrl.scope;\n              treeNodeCtrl.scope.$handleScope = scope;\n            }\n          }\n        };\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n    .directive('uiTreeNode', ['treeConfig', 'UiTreeHelper', '$window', '$document', '$timeout', '$q',\n      function (treeConfig, UiTreeHelper, $window, $document, $timeout, $q) {\n        return {\n          require: ['^uiTreeNodes', '^uiTree'],\n          restrict: 'A',\n          controller: 'TreeNodeController',\n          link: function (scope, element, attrs, controllersArr) {\n            // todo startPos is unused\n            var config = {},\n              hasTouch = 'ontouchstart' in window,\n              startPos, firstMoving, dragInfo, pos,\n              placeElm, hiddenPlaceElm, dragElm,\n              treeScope = null,\n              elements, // As a parameter for callbacks\n              dragDelaying = true,\n              dragStarted = false,\n              dragTimer = null,\n              body = document.body,\n              html = document.documentElement,\n              document_height,\n              document_width,\n              dragStart,\n              tagName,\n              dragMove,\n              dragEnd,\n              dragStartEvent,\n              dragMoveEvent,\n              dragEndEvent,\n              dragCancelEvent,\n              dragDelay,\n              bindDragStartEvents,\n              bindDragMoveEvents,\n              unbindDragMoveEvents,\n              keydownHandler,\n              outOfBounds,\n              isHandleChild,\n              el;\n\n            angular.extend(config, treeConfig);\n            if (config.nodeClass) {\n              element.addClass(config.nodeClass);\n            }\n            scope.init(controllersArr);\n\n            scope.collapsed = !!UiTreeHelper.getNodeAttribute(scope, 'collapsed') || treeConfig.defaultCollapsed;\n\t\t\tscope.expandOnHover = !!UiTreeHelper.getNodeAttribute(scope, 'expandOnHover');\n            scope.sourceOnly = scope.nodropEnabled || scope.$treeScope.nodropEnabled;\n\n            scope.$watch(attrs.collapsed, function (val) {\n              if ((typeof val) == 'boolean') {\n                scope.collapsed = val;\n              }\n            });\n\n            scope.$watch('collapsed', function (val) {\n              UiTreeHelper.setNodeAttribute(scope, 'collapsed', val);\n              attrs.$set('collapsed', val);\n            });\n\n            scope.$watch(attrs.expandOnHover, function(val) {\n              if ((typeof val) === 'boolean' || (typeof val) === 'number') {\n                scope.expandOnHover = val;\n              }\n            });\n\n\t\t\tscope.$watch('expandOnHover', function (val) {\n              UiTreeHelper.setNodeAttribute(scope, 'expandOnHover', val);\n              attrs.$set('expandOnHover', val);\n            });\n\n            scope.$on('angular-ui-tree:collapse-all', function () {\n              scope.collapsed = true;\n            });\n\n            scope.$on('angular-ui-tree:expand-all', function () {\n              scope.collapsed = false;\n            });\n\n            /**\n             * Called when the user has grabbed a node and started dragging it\n             * @param e\n             */\n            dragStart = function (e) {\n              // disable right click\n              if (!hasTouch && (e.button === 2 || e.which === 3)) {\n                return;\n              }\n\n              // event has already fired in other scope\n              if (e.uiTreeDragging || (e.originalEvent && e.originalEvent.uiTreeDragging)) {\n                return;\n              }\n\n              // the node being dragged\n              var eventElm = angular.element(e.target),\n                isHandleChild, cloneElm, eventElmTagName, tagName,\n                eventObj, tdElm, hStyle,\n                isTreeNode,\n                isTreeNodeHandle;\n\n              // if the target element is a child element of a ui-tree-handle,\n              // use the containing handle element as target element\n              isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(eventElm);\n              if (isHandleChild) {\n                eventElm = angular.element(isHandleChild);\n              }\n\n              cloneElm = element.clone();\n              isTreeNode = UiTreeHelper.elementIsTreeNode(eventElm);\n              isTreeNodeHandle = UiTreeHelper.elementIsTreeNodeHandle(eventElm);\n\n              if (!isTreeNode && !isTreeNodeHandle) {\n                return;\n              }\n\n              if (isTreeNode && UiTreeHelper.elementContainsTreeNodeHandler(eventElm)) {\n                return;\n              }\n\n              eventElmTagName = eventElm.prop('tagName').toLowerCase();\n              if (eventElmTagName == 'input' ||\n                eventElmTagName == 'textarea' ||\n                eventElmTagName == 'button' ||\n                eventElmTagName == 'select') { // if it's a input or button, ignore it\n                return;\n              }\n\n              // check if it or it's parents has a 'data-nodrag' attribute\n              el = angular.element(e.target);\n              while (el && el[0] && el[0] !== element) {\n                if (UiTreeHelper.nodrag(el)) { // if the node mark as `nodrag`, DONOT drag it.\n                  return;\n                }\n                el = el.parent();\n              }\n\n              if (!scope.beforeDrag(scope)) {\n                return;\n              }\n\n              e.uiTreeDragging = true; // stop event bubbling\n              if (e.originalEvent) {\n                e.originalEvent.uiTreeDragging = true;\n              }\n              e.preventDefault();\n              eventObj = UiTreeHelper.eventObj(e);\n\n              firstMoving = true;\n              dragInfo = UiTreeHelper.dragInfo(scope);\n\n              tagName = element.prop('tagName');\n\n              if (tagName.toLowerCase() === 'tr') {\n                placeElm = angular.element($window.document.createElement(tagName));\n                tdElm = angular.element($window.document.createElement('td'))\n                  .addClass(config.placeholderClass)\n                  .attr('colspan', element[0].children.length);\n                placeElm.append(tdElm);\n              } else {\n                placeElm = angular.element($window.document.createElement(tagName))\n                  .addClass(config.placeholderClass);\n              }\n              hiddenPlaceElm = angular.element($window.document.createElement(tagName));\n              if (config.hiddenClass) {\n                hiddenPlaceElm.addClass(config.hiddenClass);\n              }\n\n              pos = UiTreeHelper.positionStarted(eventObj, element);\n              placeElm.css('height', UiTreeHelper.height(element) + 'px');\n\n              dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName')))\n                .addClass(scope.$parentNodesScope.$element.attr('class')).addClass(config.dragClass);\n              dragElm.css('width', UiTreeHelper.width(element) + 'px');\n              dragElm.css('z-index', 9999);\n\n              // Prevents cursor to change rapidly in Opera 12.16 and IE when dragging an element\n              hStyle = (element[0].querySelector('.angular-ui-tree-handle') || element[0]).currentStyle;\n              if (hStyle) {\n                document.body.setAttribute('ui-tree-cursor', $document.find('body').css('cursor') || '');\n                $document.find('body').css({'cursor': hStyle.cursor + '!important'});\n              }\n\n              if (scope.sourceOnly) {\n                placeElm.css('display', 'none');\n              }\n              element.after(placeElm);\n              element.after(hiddenPlaceElm);\n              if (dragInfo.isClone() && scope.sourceOnly) {\n                dragElm.append(cloneElm);\n              } else {\n                dragElm.append(element);\n              }\n\n              $document.find('body').append(dragElm);\n\n              dragElm.css({\n                'left': eventObj.pageX - pos.offsetX + 'px',\n                'top': eventObj.pageY - pos.offsetY + 'px'\n              });\n              elements = {\n                placeholder: placeElm,\n                dragging: dragElm\n              };\n\n              bindDragMoveEvents();\n              // Fire dragStart callback\n              scope.$apply(function () {\n                scope.$treeScope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));\n              });\n\n              document_height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n              document_width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n            };\n\n            dragMove = function (e) {\n              var eventObj = UiTreeHelper.eventObj(e),\n                prev,\n                next,\n                leftElmPos,\n                topElmPos,\n                top_scroll,\n                bottom_scroll,\n                target,\n                decrease,\n                targetX,\n                targetY,\n                displayElm,\n                targetNode,\n                targetElm,\n                isEmpty,\n                scrollDownBy,\n                targetOffset,\n                targetBefore;\n\n              if (dragElm) {\n                e.preventDefault();\n\n                if ($window.getSelection) {\n                  $window.getSelection().removeAllRanges();\n                } else if ($window.document.selection) {\n                  $window.document.selection.empty();\n                }\n\n                leftElmPos = eventObj.pageX - pos.offsetX;\n                topElmPos = eventObj.pageY - pos.offsetY;\n\n                //dragElm can't leave the screen on the left\n                if (leftElmPos < 0) {\n                  leftElmPos = 0;\n                }\n\n                //dragElm can't leave the screen on the top\n                if (topElmPos < 0) {\n                  topElmPos = 0;\n                }\n\n                //dragElm can't leave the screen on the bottom\n                if ((topElmPos + 10) > document_height) {\n                  topElmPos = document_height - 10;\n                }\n\n                //dragElm can't leave the screen on the right\n                if ((leftElmPos + 10) > document_width) {\n                  leftElmPos = document_width - 10;\n                }\n\n                dragElm.css({\n                  'left': leftElmPos + 'px',\n                  'top': topElmPos + 'px'\n                });\n\n                top_scroll = window.pageYOffset || $window.document.documentElement.scrollTop;\n                bottom_scroll = top_scroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);\n\n                // to scroll down if cursor y-position is greater than the bottom position the vertical scroll\n                if (bottom_scroll < eventObj.pageY && bottom_scroll < document_height) {\n                  scrollDownBy = Math.min(document_height - bottom_scroll, 10);\n                  window.scrollBy(0, scrollDownBy);\n                }\n\n                // to scroll top if cursor y-position is less than the top position the vertical scroll\n                if (top_scroll > eventObj.pageY) {\n                  window.scrollBy(0, -10);\n                }\n\n                UiTreeHelper.positionMoved(e, pos, firstMoving);\n                if (firstMoving) {\n                  firstMoving = false;\n                  return;\n                }\n\n                // check if add it as a child node first\n                // todo decrease is unused\n                decrease = (UiTreeHelper.offset(dragElm).left - UiTreeHelper.offset(placeElm).left) >= config.threshold;\n\n                targetX = eventObj.pageX - ($window.pageXOffset ||\n                  $window.document.body.scrollLeft ||\n                  $window.document.documentElement.scrollLeft) -\n                  ($window.document.documentElement.clientLeft || 0);\n\n                targetY = eventObj.pageY - ($window.pageYOffset ||\n                  $window.document.body.scrollTop ||\n                  $window.document.documentElement.scrollTop) -\n                  ($window.document.documentElement.clientTop || 0);\n\n                // Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always\n                // pick the drag element itself as the target. To prevent this, we hide the drag element while\n                // selecting the target.\n                if (angular.isFunction(dragElm.hide)) {\n                  dragElm.hide();\n                } else {\n                  displayElm = dragElm[0].style.display;\n                  dragElm[0].style.display = 'none';\n                }\n\n                // when using elementFromPoint() inside an iframe, you have to call\n                // elementFromPoint() twice to make sure IE8 returns the correct value\n                $window.document.elementFromPoint(targetX, targetY);\n\n                targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));\n\n                // if the target element is a child element of a ui-tree-handle,\n                // use the containing handle element as target element\n                isHandleChild = UiTreeHelper.treeNodeHandlerContainerOfElement(targetElm);\n                if (isHandleChild) {\n                  targetElm = angular.element(isHandleChild);\n                }\n\n                if (angular.isFunction(dragElm.show)) {\n                  dragElm.show();\n                } else {\n                  dragElm[0].style.display = displayElm;\n                }\n\n                outOfBounds = !UiTreeHelper.elementIsTreeNodeHandle(targetElm) &&\n                              !UiTreeHelper.elementIsTreeNode(targetElm) &&\n                              !UiTreeHelper.elementIsTreeNodes(targetElm) &&\n                              !UiTreeHelper.elementIsTree(targetElm) &&\n                              !UiTreeHelper.elementIsPlaceholder(targetElm);\n\n                // Detect out of bounds condition, update drop target display, and prevent drop\n                if (outOfBounds) {\n\n                  // Remove the placeholder\n                  placeElm.remove();\n\n                  // If the target was an empty tree, replace the empty element placeholder\n                  if (treeScope) {\n                    treeScope.resetEmptyElement();\n                    treeScope = null;\n                  }\n                }\n\n                // move horizontal\n                if (pos.dirAx && pos.distAxX >= config.levelThreshold) {\n                  pos.distAxX = 0;\n\n                  // increase horizontal level if previous sibling exists and is not collapsed\n                  if (pos.distX > 0) {\n                    prev = dragInfo.prev();\n                    if (prev && !prev.collapsed\n                      && prev.accept(scope, prev.childNodesCount())) {\n                      prev.$childNodesScope.$element.append(placeElm);\n                      dragInfo.moveTo(prev.$childNodesScope, prev.childNodes(), prev.childNodesCount());\n                    }\n                  }\n\n                  // decrease horizontal level\n                  if (pos.distX < 0) {\n                    // we can't decrease a level if an item preceeds the current one\n                    next = dragInfo.next();\n                    if (!next) {\n                      target = dragInfo.parentNode(); // As a sibling of it's parent node\n                      if (target\n                        && target.$parentNodesScope.accept(scope, target.index() + 1)) {\n                        target.$element.after(placeElm);\n                        dragInfo.moveTo(target.$parentNodesScope, target.siblings(), target.index() + 1);\n                      }\n                    }\n                  }\n                }\n\n                // move vertical\n                if (!pos.dirAx) {\n                  if (UiTreeHelper.elementIsTree(targetElm)) {\n                    targetNode = targetElm.controller('uiTree').scope;\n                  } else if (UiTreeHelper.elementIsTreeNodeHandle(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeHandle').scope;\n                  } else if (UiTreeHelper.elementIsTreeNode(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNode').scope;\n                  } else if (UiTreeHelper.elementIsTreeNodes(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNodes').scope;\n                  } else if (UiTreeHelper.elementIsPlaceholder(targetElm)) {\n                    targetNode = targetElm.controller('uiTreeNodes').scope;\n                  } else if (targetElm.controller('uiTreeNode')) {\n                    // is a child element of a node\n                    targetNode = targetElm.controller('uiTreeNode').scope;\n                  }\n\n                  // check it's new position\n                  isEmpty = false;\n                  if (!targetNode) {\n                    return;\n                  }\n\n                  // Show the placeholder if it was hidden for nodrop-enabled and this is a new tree\n                  if (targetNode.$treeScope && !targetNode.$parent.nodropEnabled && !targetNode.$treeScope.nodropEnabled) {\n                    placeElm.css('display', '');\n                  }\n\n                  if (targetNode.$type == 'uiTree' && targetNode.dragEnabled) {\n                    isEmpty = targetNode.isEmpty(); // Check if it's empty tree\n                  }\n\n                  if (targetNode.$type == 'uiTreeHandle') {\n                    targetNode = targetNode.$nodeScope;\n                  }\n\n                  if (targetNode.$type != 'uiTreeNode'\n                    && !isEmpty) { // Check if it is a uiTreeNode or it's an empty tree\n                    return;\n                  }\n\n                  // if placeholder move from empty tree, reset it.\n                  if (treeScope && placeElm.parent()[0] != treeScope.$element[0]) {\n                    treeScope.resetEmptyElement();\n                    treeScope = null;\n                  }\n\n                  if (isEmpty) { // it's an empty tree\n                    treeScope = targetNode;\n                    if (targetNode.$nodesScope.accept(scope, 0)) {\n                      targetNode.place(placeElm);\n                      dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);\n                    }\n                  } else if (targetNode.dragEnabled()) { // drag enabled\n                      if (angular.isDefined(scope.expandTimeoutOn) && scope.expandTimeoutOn !== targetNode.id) {\n                        $timeout.cancel(scope.expandTimeout);\n                        delete scope.expandTimeout;\n                        delete scope.expandTimeoutOn;\n\n                        scope.$callbacks.expandTimeoutCancel();\n                      }\n\n                      if (targetNode.collapsed) {\n                        if (scope.expandOnHover === true || (angular.isNumber(scope.expandOnHover) && scope.expandOnHover === 0)) {\n                          targetNode.collapsed = false;\n                        } else if (scope.expandOnHover !== false && angular.isNumber(scope.expandOnHover) && scope.expandOnHover > 0) {\n                          if (angular.isUndefined(scope.expandTimeoutOn)) {\n                            scope.expandTimeoutOn = targetNode.$id;\n\n                            scope.$callbacks.expandTimeoutStart();\n                            scope.expandTimeout = $timeout(function()\n                            {\n                              scope.$callbacks.expandTimeoutEnd();\n                              targetNode.collapsed = false;\n                            }, scope.expandOnHover);\n                          }\n                        }\n                      }\n\n                    targetElm = targetNode.$element; // Get the element of ui-tree-node\n                    targetOffset = UiTreeHelper.offset(targetElm);\n                    targetBefore = targetNode.horizontal ? eventObj.pageX < (targetOffset.left + UiTreeHelper.width(targetElm) / 2)\n                      : eventObj.pageY < (targetOffset.top + UiTreeHelper.height(targetElm) / 2);\n\n                    if (targetNode.$parentNodesScope.accept(scope, targetNode.index())) {\n                      if (targetBefore) {\n                        targetElm[0].parentNode.insertBefore(placeElm[0], targetElm[0]);\n                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index());\n                      } else {\n                        targetElm.after(placeElm);\n                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index() + 1);\n                      }\n                    } else if (!targetBefore && targetNode.accept(scope, targetNode.childNodesCount())) { // we have to check if it can add the dragging node as a child\n                      targetNode.$childNodesScope.$element.append(placeElm);\n                      dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), targetNode.childNodesCount());\n                    } else {\n                      outOfBounds = true;\n                    }\n                  }\n                }\n\n                scope.$apply(function () {\n                  scope.$treeScope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));\n                });\n              }\n            };\n\n            dragEnd = function (e) {\n              var dragEventArgs = dragInfo.eventArgs(elements, pos);\n              e.preventDefault();\n              unbindDragMoveEvents();\n\n              $timeout.cancel(scope.expandTimeout);\n\n              scope.$treeScope.$apply(function () {\n                $q.when(scope.$treeScope.$callbacks.beforeDrop(dragEventArgs))\n                    // promise resolved (or callback didn't return false)\n                    .then(function (allowDrop) {\n                      if (allowDrop !== false && scope.$$allowNodeDrop && !outOfBounds) { // node drop accepted)\n                        dragInfo.apply();\n                        // fire the dropped callback only if the move was successful\n                        scope.$treeScope.$callbacks.dropped(dragEventArgs);\n                      } else { // drop canceled - revert the node to its original position\n                        bindDragStartEvents();\n                      }\n                    })\n                    // promise rejected - revert the node to its original position\n                    .catch(function () {\n                      bindDragStartEvents();\n                    })\n                    .finally(function () {\n                      hiddenPlaceElm.replaceWith(scope.$element);\n                      placeElm.remove();\n\n                      if (dragElm) { // drag element is attached to the mouse pointer\n                        dragElm.remove();\n                        dragElm = null;\n                      }\n                      scope.$treeScope.$callbacks.dragStop(dragEventArgs);\n                      scope.$$allowNodeDrop = false;\n                      dragInfo = null;\n\n                      // Restore cursor in Opera 12.16 and IE\n                      var oldCur = document.body.getAttribute('ui-tree-cursor');\n                      if (oldCur !== null) {\n                        $document.find('body').css({'cursor': oldCur});\n                        document.body.removeAttribute('ui-tree-cursor');\n                      }\n                    });\n              });\n            };\n\n            dragStartEvent = function (e) {\n              if (scope.dragEnabled()) {\n                dragStart(e);\n              }\n            };\n\n            dragMoveEvent = function (e) {\n              dragMove(e);\n            };\n\n            dragEndEvent = function (e) {\n              scope.$$allowNodeDrop = true;\n              dragEnd(e);\n            };\n\n            dragCancelEvent = function (e) {\n              dragEnd(e);\n            };\n\n            dragDelay = (function () {\n              var to;\n\n              return {\n                exec: function (fn, ms) {\n                  if (!ms) {\n                    ms = 0;\n                  }\n                  this.cancel();\n                  to = $timeout(fn, ms);\n                },\n                cancel: function () {\n                  $timeout.cancel(to);\n                }\n              };\n            })();\n\n            /**\n             * Binds the mouse/touch events to enable drag start for this node\n             */\n            bindDragStartEvents = function () {\n              element.bind('touchstart mousedown', function (e) {\n                dragDelay.exec(function () {\n                  dragStartEvent(e);\n                }, scope.dragDelay || 0);\n              });\n              element.bind('touchend touchcancel mouseup', function () {\n                dragDelay.cancel();\n              });\n            };\n            bindDragStartEvents();\n\n            /**\n             * Binds mouse/touch events that handle moving/dropping this dragged node\n             */\n            bindDragMoveEvents = function () {\n              angular.element($document).bind('touchend', dragEndEvent);\n              angular.element($document).bind('touchcancel', dragEndEvent);\n              angular.element($document).bind('touchmove', dragMoveEvent);\n              angular.element($document).bind('mouseup', dragEndEvent);\n              angular.element($document).bind('mousemove', dragMoveEvent);\n              angular.element($document).bind('mouseleave', dragCancelEvent);\n            };\n\n            /**\n             * Unbinds mouse/touch events that handle moving/dropping this dragged node\n             */\n            unbindDragMoveEvents = function () {\n              angular.element($document).unbind('touchend', dragEndEvent);\n              angular.element($document).unbind('touchcancel', dragEndEvent);\n              angular.element($document).unbind('touchmove', dragMoveEvent);\n              angular.element($document).unbind('mouseup', dragEndEvent);\n              angular.element($document).unbind('mousemove', dragMoveEvent);\n              angular.element($document).unbind('mouseleave', dragCancelEvent);\n            };\n\n            keydownHandler = function (e) {\n              if (e.keyCode == 27) {\n                scope.$$allowNodeDrop = false;\n                dragEnd(e);\n              }\n            };\n\n            angular.element($window.document).bind('keydown', keydownHandler);\n\n            //unbind handler that retains scope\n            scope.$on('$destroy', function () {\n              angular.element($window.document).unbind('keydown', keydownHandler);\n            });\n          }\n        };\n      }\n    ]);\n\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n    .directive('uiTreeNodes', ['treeConfig', '$window',\n      function (treeConfig) {\n        return {\n          require: ['ngModel', '?^uiTreeNode', '^uiTree'],\n          restrict: 'A',\n          scope: true,\n          controller: 'TreeNodesController',\n          link: function (scope, element, attrs, controllersArr) {\n\n            var config = {},\n                ngModel = controllersArr[0],\n                treeNodeCtrl = controllersArr[1],\n                treeCtrl = controllersArr[2];\n\n            angular.extend(config, treeConfig);\n            if (config.nodesClass) {\n              element.addClass(config.nodesClass);\n            }\n\n            if (treeNodeCtrl) {\n              treeNodeCtrl.scope.$childNodesScope = scope;\n              scope.$nodeScope = treeNodeCtrl.scope;\n            } else {\n              // find the root nodes if there is no parent node and have a parent ui-tree\n              treeCtrl.scope.$nodesScope = scope;\n            }\n            scope.$treeScope = treeCtrl.scope;\n\n            if (ngModel) {\n              ngModel.$render = function () {\n                scope.$modelValue = ngModel.$modelValue;\n              };\n            }\n\n            scope.$watch(function () {\n              return attrs.maxDepth;\n            }, function (val) {\n              if ((typeof val) == 'number') {\n                scope.maxDepth = val;\n              }\n            });\n\n            scope.$watch(function () {\n              return attrs.nodropEnabled;\n            }, function (newVal) {\n              if ((typeof newVal) != 'undefined') {\n                scope.nodropEnabled = true;\n              }\n            }, true);\n\n            attrs.$observe('horizontal', function (val) {\n              scope.horizontal = ((typeof val) != 'undefined');\n            });\n\n          }\n        };\n      }\n    ]);\n})();\n\n(function () {\n  'use strict';\n\n  angular.module('ui.tree')\n\n  /**\n   * @ngdoc service\n   * @name ui.tree.service:UiTreeHelper\n   * @requires ng.$document\n   * @requires ng.$window\n   *\n   * @description\n   * angular-ui-tree.\n   */\n    .factory('UiTreeHelper', ['$document', '$window', 'treeConfig',\n      function ($document, $window, treeConfig) {\n        return {\n\n          /**\n           * A hashtable used to storage data of nodes\n           * @type {Object}\n           */\n          nodesData: {},\n\n          setNodeAttribute: function (scope, attrName, val) {\n            if (!scope.$modelValue) {\n              return null;\n            }\n            var data = this.nodesData[scope.$modelValue.$$hashKey];\n            if (!data) {\n              data = {};\n              this.nodesData[scope.$modelValue.$$hashKey] = data;\n            }\n            data[attrName] = val;\n          },\n\n          getNodeAttribute: function (scope, attrName) {\n            if (!scope.$modelValue) {\n              return null;\n            }\n            var data = this.nodesData[scope.$modelValue.$$hashKey];\n            if (data) {\n              return data[attrName];\n            }\n            return null;\n          },\n\n          /**\n           * @ngdoc method\n           * @methodOf ui.tree.service:$nodrag\n           * @param  {Object} targetElm angular element\n           * @return {Bool} check if the node can be dragged.\n           */\n          nodrag: function (targetElm) {\n            if (typeof targetElm.attr('data-nodrag') != 'undefined') {\n              return targetElm.attr('data-nodrag') !== 'false';\n            }\n            return false;\n          },\n\n          /**\n           * get the event object for touches\n           * @param  {[type]} e [description]\n           * @return {[type]}   [description]\n           */\n          eventObj: function (e) {\n            var obj = e;\n            if (e.targetTouches !== undefined) {\n              obj = e.targetTouches.item(0);\n            } else if (e.originalEvent !== undefined && e.originalEvent.targetTouches !== undefined) {\n              obj = e.originalEvent.targetTouches.item(0);\n            }\n            return obj;\n          },\n\n          dragInfo: function (node) {\n            return {\n              source: node,\n              sourceInfo: {\n                cloneModel: node.$treeScope.cloneEnabled === true ? angular.copy(node.$modelValue) : undefined,\n                nodeScope: node,\n                index: node.index(),\n                nodesScope: node.$parentNodesScope\n              },\n              index: node.index(),\n              siblings: node.siblings().slice(0),\n              parent: node.$parentNodesScope,\n\n              // Move the node to a new position\n              moveTo: function (parent, siblings, index) {\n                this.parent = parent;\n                this.siblings = siblings.slice(0);\n\n                // If source node is in the target nodes\n                var i = this.siblings.indexOf(this.source);\n                if (i > -1) {\n                  this.siblings.splice(i, 1);\n                  if (this.source.index() < index) {\n                    index--;\n                  }\n                }\n\n                this.siblings.splice(index, 0, this.source);\n                this.index = index;\n              },\n\n              parentNode: function () {\n                return this.parent.$nodeScope;\n              },\n\n              prev: function () {\n                if (this.index > 0) {\n                  return this.siblings[this.index - 1];\n                }\n\n                return null;\n              },\n\n              next: function () {\n                if (this.index < this.siblings.length - 1) {\n                  return this.siblings[this.index + 1];\n                }\n\n                return null;\n              },\n\n              isClone: function () {\n                return this.source.$treeScope.cloneEnabled === true;\n              },\n\n              clonedNode: function (node) {\n                return angular.copy(node);\n              },\n\n              isDirty: function () {\n                return this.source.$parentNodesScope != this.parent ||\n                  this.source.index() != this.index;\n              },\n\n              isForeign: function () {\n                return this.source.$treeScope !== this.parent.$treeScope;\n              },\n\n              eventArgs: function (elements, pos) {\n                return {\n                  source: this.sourceInfo,\n                  dest: {\n                    index: this.index,\n                    nodesScope: this.parent\n                  },\n                  elements: elements,\n                  pos: pos\n                };\n              },\n\n              apply: function () {\n\n                var nodeData = this.source.$modelValue;\n\n                // nodrop enabled on tree or parent\n                if (this.parent.nodropEnabled || this.parent.$treeScope.nodropEnabled) {\n                  return;\n                }\n\n                // node was dropped in the same place - do nothing\n                if (!this.isDirty()) {\n                  return;\n                }\n\n                // cloneEnabled and cross-tree so copy and do not remove from source\n                if (this.isClone() && this.isForeign()) {\n                  this.parent.insertNode(this.index, this.sourceInfo.cloneModel);\n                } else { // Any other case, remove and reinsert\n                  this.source.remove();\n                  this.parent.insertNode(this.index, nodeData);\n                }\n              }\n            };\n          },\n\n          /**\n           * @ngdoc method\n           * @name ui.tree#height\n           * @methodOf ui.tree.service:UiTreeHelper\n           *\n           * @description\n           * Get the height of an element.\n           *\n           * @param {Object} element Angular element.\n           * @returns {String} Height\n           */\n          height: function (element) {\n            return element.prop('scrollHeight');\n          },\n\n          /**\n           * @ngdoc method\n           * @name ui.tree#width\n           * @methodOf ui.tree.service:UiTreeHelper\n           *\n           * @description\n           * Get the width of an element.\n           *\n           * @param {Object} element Angular element.\n           * @returns {String} Width\n           */\n          width: function (element) {\n            return element.prop('scrollWidth');\n          },\n\n          /**\n           * @ngdoc method\n           * @name ui.tree#offset\n           * @methodOf ui.nestedSortable.service:UiTreeHelper\n           *\n           * @description\n           * Get the offset values of an element.\n           *\n           * @param {Object} element Angular element.\n           * @returns {Object} Object with properties width, height, top and left\n           */\n          offset: function (element) {\n            var boundingClientRect = element[0].getBoundingClientRect();\n\n            return {\n              width: element.prop('offsetWidth'),\n              height: element.prop('offsetHeight'),\n              top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),\n              left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)\n            };\n          },\n\n          /**\n           * @ngdoc method\n           * @name ui.tree#positionStarted\n           * @methodOf ui.tree.service:UiTreeHelper\n           *\n           * @description\n           * Get the start position of the target element according to the provided event properties.\n           *\n           * @param {Object} e Event\n           * @param {Object} target Target element\n           * @returns {Object} Object with properties offsetX, offsetY, startX, startY, nowX and dirX.\n           */\n          positionStarted: function (e, target) {\n            var pos = {},\n              pageX = e.pageX,\n              pageY = e.pageY;\n\n            if (e.originalEvent && e.originalEvent.touches && (e.originalEvent.touches.length > 0)) {\n              pageX = e.originalEvent.touches[0].pageX;\n              pageY = e.originalEvent.touches[0].pageY;\n            }\n            pos.offsetX = pageX - this.offset(target).left;\n            pos.offsetY = pageY - this.offset(target).top;\n            pos.startX = pos.lastX = pageX;\n            pos.startY = pos.lastY = pageY;\n            pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;\n            pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;\n            return pos;\n          },\n\n          positionMoved: function (e, pos, firstMoving) {\n            var pageX = e.pageX,\n              pageY = e.pageY,\n              newAx;\n            if (e.originalEvent && e.originalEvent.touches && (e.originalEvent.touches.length > 0)) {\n              pageX = e.originalEvent.touches[0].pageX;\n              pageY = e.originalEvent.touches[0].pageY;\n            }\n            // mouse position last events\n            pos.lastX = pos.nowX;\n            pos.lastY = pos.nowY;\n\n            // mouse position this events\n            pos.nowX = pageX;\n            pos.nowY = pageY;\n\n            // distance mouse moved between events\n            pos.distX = pos.nowX - pos.lastX;\n            pos.distY = pos.nowY - pos.lastY;\n\n            // direction mouse was moving\n            pos.lastDirX = pos.dirX;\n            pos.lastDirY = pos.dirY;\n\n            // direction mouse is now moving (on both axis)\n            pos.dirX = pos.distX === 0 ? 0 : pos.distX > 0 ? 1 : -1;\n            pos.dirY = pos.distY === 0 ? 0 : pos.distY > 0 ? 1 : -1;\n\n            // axis mouse is now moving on\n            newAx = Math.abs(pos.distX) > Math.abs(pos.distY) ? 1 : 0;\n\n            // do nothing on first move\n            if (firstMoving) {\n              pos.dirAx = newAx;\n              pos.moving = true;\n              return;\n            }\n\n            // calc distance moved on this axis (and direction)\n            if (pos.dirAx !== newAx) {\n              pos.distAxX = 0;\n              pos.distAxY = 0;\n            } else {\n              pos.distAxX += Math.abs(pos.distX);\n              if (pos.dirX !== 0 && pos.dirX !== pos.lastDirX) {\n                pos.distAxX = 0;\n              }\n\n              pos.distAxY += Math.abs(pos.distY);\n              if (pos.dirY !== 0 && pos.dirY !== pos.lastDirY) {\n                pos.distAxY = 0;\n              }\n            }\n\n            pos.dirAx = newAx;\n          },\n\n          elementIsTreeNode: function (element) {\n            return typeof element.attr('ui-tree-node') !== 'undefined';\n          },\n\n          elementIsTreeNodeHandle: function (element) {\n            return typeof element.attr('ui-tree-handle') !== 'undefined';\n          },\n          elementIsTree: function (element) {\n            return typeof element.attr('ui-tree') !== 'undefined';\n          },\n          elementIsTreeNodes: function (element) {\n            return typeof element.attr('ui-tree-nodes') !== 'undefined';\n          },\n          elementIsPlaceholder: function (element) {\n            return element.hasClass(treeConfig.placeholderClass);\n          },\n          elementContainsTreeNodeHandler: function (element) {\n            return element[0].querySelectorAll('[ui-tree-handle]').length >= 1;\n          },\n          treeNodeHandlerContainerOfElement: function (element) {\n            return findFirstParentElementWithAttribute('ui-tree-handle', element[0]);\n          }\n        };\n      }\n    ]);\n\n  // TODO: optimize this loop\n  function findFirstParentElementWithAttribute(attributeName, childObj) {\n    // undefined if the mouse leaves the browser window\n    if (childObj === undefined) {\n      return null;\n    }\n    var testObj = childObj.parentNode,\n      count = 1,\n      // check for setAttribute due to exception thrown by Firefox when a node is dragged outside the browser window\n      res = (typeof testObj.setAttribute === 'function' && testObj.hasAttribute(attributeName)) ? testObj : null;\n    while (testObj && typeof testObj.setAttribute === 'function' && !testObj.hasAttribute(attributeName)) {\n      testObj = testObj.parentNode;\n      res = testObj;\n      if (testObj === document.documentElement) {\n        res = null;\n        break;\n      }\n      count++;\n    }\n\n    return res;\n  }\n\n})();\n","(function(){\n    var app = angular.module('mks-dashboard', ['ngSanitize']);\n\n    app.component('dashboardNotifications', {\n        templateUrl: ['UrlBuilder', function(UrlBuilder) {\n            return UrlBuilder.get('templates/dashboard-notifications.html');\n        }],\n        bindings: {\n            url: '@'\n        },\n        controller: ['$http', 'UrlBuilder', '$sce', function($http, UrlBuilder, $sce) {\n            this.items = [];\n            this.nextUrl = null;\n            this.totalCount = 0;\n            this.unreadCount = 0;\n            this.currentItem = null;\n            this.detailsHtml = null;\n\n            var ctrl = this;\n\n            function updateCounts() {\n                var count = 0;\n                angular.forEach(ctrl.items, function(item) {\n                    if (!item.read_at) {\n                        count++;\n                    }\n                });\n                ctrl.unreadCount = count;\n            }\n\n            this.load = function() {\n                $http.get(this.nextUrl || this.url).then(function(r) {\n                    if (r.data) {\n                        ctrl.items = ctrl.items.concat(r.data.data);\n                        ctrl.nextUrl = r.data.next_page_url;\n                        ctrl.totalCount = r.data.total;\n                        updateCounts();\n                    }\n                });\n            };\n            \n            this.details = function (item) {\n                $http.get(UrlBuilder.get('dashboard/notification-details/' + item.id)).then(function (r) {\n                    if (r.data) {\n                        ctrl.detailsHtml = $sce.trustAsHtml(r.data.details);\n                        item.read_at = r.data.read_at;\n                        updateCounts();\n                        ctrl.currentItem = item;\n                    }\n                });\n            };\n\n            this.delete = function(item, confirmation) {\n                if (confirmation && !confirm(confirmation)) {\n                    return false;\n                }\n\n                $http.post(UrlBuilder.get('dashboard/notification-delete/' + item.id)).then(function (r) {\n                    var i = ctrl.items.indexOf(item);\n                    if (i >= 0) {\n                        ctrl.items.splice(i, 1);\n                        ctrl.totalCount--;\n                        updateCounts();\n                    }\n                });\n            };\n\n            this.refresh = function() {\n                this.items = [];\n                this.nextUrl = null;\n                this.load();\n            };\n\n            function deleteMany(url, confirmation) {\n                if (confirmation && !confirm(confirmation)) {\n                    return false;\n                }\n\n                $http.post(url).then(function (r) {\n                    ctrl.refresh();\n                });\n            }\n\n            this.deleteRead = function(confirmation) {\n                deleteMany(UrlBuilder.get('dashboard/notifications-delete'), confirmation);\n            };\n\n            this.deleteAll = function(confirmation) {\n                deleteMany(UrlBuilder.get('dashboard/notifications-delete/all'), confirmation);\n            };\n\n            this.load();\n        }]\n    });\n\n    app.component('dashboardStatistics', {\n        templateUrl: ['UrlBuilder', function(UrlBuilder) {\n            return UrlBuilder.get('templates/dashboard-statistics.html');\n        }],\n        bindings: {\n            url: '@'\n        },\n        controller: ['$http', 'UrlBuilder', function($http, UrlBuilder) {\n            var ctrl = this;\n\n            this.items = [];\n\n            this.load = function() {\n                $http.get(this.url).then(function(r) {\n                    if (r.data) {\n                        ctrl.items = r.data;\n                    }\n                });\n            };\n\n            this.load();\n        }]\n    });\n\n})(window.angular);\n","(function(){\n    var app = angular.module('mks-menu-manager', ['ui.tree']);\n\n    app.controller('MenuController', ['$scope', '$http', 'UrlBuilder', '$location',\n        function($scope, $http, UrlBuilder, $location) {\n\n        $scope.menu = [];\n        $scope.currentMenu = null;\n        $scope.menuModel = null;\n        $scope.prevMenu = null;\n        $scope.menuItems = {};\n\n        var self = this;\n\n        $scope.init = function(menuId) {\n            $http.get(UrlBuilder.get('menuman/list')).then(function(r) {\n                $scope.menu = r.data;\n                if ($scope.menu.length) {\n                    if (menuId) {\n                        $scope.selectMenu(self.getMenu(menuId));\n                    } else {\n                        $scope.selectMenu($scope.menu[0]);\n                    }\n                }\n            });\n        };\n\n        this.getMenu = function(id) {\n            for (var i = 0; i < $scope.menu.length; i++) {\n                if ($scope.menu[i].id == id) {\n                    return $scope.menu[i];\n                }\n            }\n\n            return false;\n        };\n\n        this.getMenuIndex = function(id) {\n            for (var i = 0; i < $scope.menu.length; i++) {\n                if ($scope.menu[i].id == id) {\n                    return i;\n                }\n            }\n\n            return false;\n        };\n\n        this.loadMenuItems = function(menuId) {\n          if (!$scope.menuItems[menuId]) {\n              $http.get(UrlBuilder.get('menuman/items/'+menuId)).then(function(r) {\n                  $scope.menuItems[menuId] = r.data;\n              });\n          }\n        };\n\n        $scope.selectMenu = function(item) {\n            $scope.currentMenu = item;\n            $scope.prevMenu = item;\n            $scope.menuModel = null;\n            self.loadMenuItems(item.id);\n        };\n\n        $scope.addMenu = function () {\n            $scope.currentMenu = null;\n            $scope.menuModel = {active: true};\n        };\n\n        $scope.editMenu = function (item) {\n            $scope.currentMenu = null;\n            $scope.menuModel = angular.copy(item);\n        };\n\n        $scope.saveMenu = function () {\n            if (!$scope.menuModel) {\n                return false;\n            }\n\n            $http.post(UrlBuilder.get('menuman/save'), $scope.menuModel).then(function(r) {\n                if (!r.data.id) {\n                    return false;\n                }\n\n                if (!$scope.menuModel.id) {\n                    $scope.menu.push(r.data);\n                    $scope.selectMenu(r.data);\n                } else {\n                    var i = self.getMenuIndex(r.data.id);\n                    if (i >= 0) {\n                        $scope.menu[i] = r.data;\n                        $scope.selectMenu($scope.menu[i]);\n                    }\n                }\n            });\n        };\n\n        $scope.cancel = function() {\n            if (!$scope.menuModel || !$scope.prevMenu) {\n                return false;\n            }\n\n            $scope.selectMenu($scope.prevMenu);\n        };\n\n        $scope.deleteMenu = function (item, msg) {\n            if (item.id && confirm(msg||'Delete?')) {\n                $http.post(UrlBuilder.get('menuman/delete'), {id: item.id}).then(function(r) {\n                    $scope.menu.splice(self.getMenuIndex(item.id), 1);\n                    if ($location.path() == '/menuman/' + item.id) {\n                        $location.path('/menuman');\n                    } else if ($scope.menu.length) {\n                        $scope.selectMenu($scope.menu[0]);\n                    }\n                });\n            }\n        }\n\n    }]);\n    \n    app.controller('MenuTreeController', ['$http', 'UrlBuilder', function($http, UrlBuilder) {\n        this.menuItem = null;\n\n        var self = this;\n\n        this.toggle = function(scope) {\n            scope.toggle();\n        };\n\n        this.remove = function(scope, msg) {\n            if (scope.$nodeScope && confirm(msg || 'Delete?')) {\n                var id = scope.$nodeScope.$modelValue.id;\n\n                $http.post(UrlBuilder.get('menuman/items/delete/' + id))\n                    .then(function(r) {\n                        scope.remove();\n                    });\n            }\n        };\n\n        this.treeOptions = {\n            beforeDrop: function(e) {\n                var params = {\n                    old: {\n                        index: e.source.index,\n                        parent: null\n                    },\n                    new: {\n                        index: e.dest.index,\n                        parent: null\n                    }\n                };\n                if (e.source.nodeScope.$parentNodeScope) {\n                    params.old.parent = e.source.nodeScope.$parentNodeScope.$modelValue.id;\n                }\n\n                if (e.dest.nodesScope.$nodeScope) {\n                    params.new.parent = e.dest.nodesScope.$nodeScope.$modelValue.id;\n                }\n\n                if (params.old.index == params.new.index && params.old.parent == params.new.parent) {\n                    return false;\n                }\n\n                var menu_id = e.source.nodeScope.$modelValue.menu_id;\n                var id = e.source.nodeScope.$modelValue.id;\n\n                return $http.post(UrlBuilder.get('menuman/items/' + menu_id + '/move/' + id), params)\n                    .then(function(r) {\n                        return true;\n                    });\n            }\n        };\n    }]);\n\n})(window.angular);","(function(){\n    var app = angular.module('mks-admin-ext', []);\n\n    app.factory('mksLinkService', ['$q', '$http', 'UrlBuilder', function($q, $http, UrlBuilder) {\n        this.getParamsData = function(params) {\n            var canceler = $q.defer();\n\n            var request = $http({\n                method: \"get\",\n                url: UrlBuilder.get('route/params'),\n                params: params,\n                timeout: canceler.promise\n            });\n\n            var promise = request.then(\n                function( response ) {\n                    return( response.data );\n                },\n                function( response ) {\n                    return( $q.reject( \"Something went wrong\" ) );\n                }\n            );\n\n            promise.abort = function() {\n                canceler.resolve();\n            };\n\n            promise.finally(\n                function() {\n                    promise.abort = angular.noop;\n                    canceler = request = promise = null;\n                }\n            );\n\n            return promise;\n        };\n\n        var _routesPromise = $http.get(UrlBuilder.get('route')).then(function(r) {\n            return r.data;\n        });\n\n        this.getRoutes = function () {\n            return _routesPromise;\n        };\n\n        return this;\n    }]);\n\n    app.directive('mksLinkSelect', ['$http', 'mksLinkService', 'UrlBuilder', function($http, mksLinkService, UrlBuilder) {\n        return {\n            restrict: 'E',\n            scope: {\n                model: '@model',\n                rawEnabled: '@rawEnabled',\n                emptyTitle: '@emptyTitle'\n            },\n            templateUrl: UrlBuilder.get('templates/link-selector.html'),\n            link: function(scope, elem, attr) {\n                scope.field = {\n                    route: attr.fieldRoute || 'route[name]',\n                    params: attr.fieldParams || 'route[params]',\n                    raw: attr.fieldRaw || 'route[raw]'\n                };\n\n                scope.items = [];\n                scope.routeOption = null;\n                scope.routes = {};\n\n                function selectRouteOption (id) {\n                    angular.forEach(scope.items, function (i) {\n                        if (i.id == id) {\n                            scope.routeOption = i;\n                        }\n                    });\n                };\n\n                if (scope.model) {\n                    scope.$watch(scope.model, function(val) {\n                        if (val && typeof val['id'] != 'undefined') {\n                            scope.route = val;\n                        }\n                    });\n                }\n\n                scope.$watch(function() {return scope.route; }, function(val) {\n                    if (val && typeof val['id'] != 'undefined' && typeof scope.routes[val.id] == 'undefined') {\n                        scope.routes[val.id] = val;\n                        selectRouteOption(val.id);\n                    }\n                });\n\n                scope.route = {\n                    id: attr.route,\n                    title: attr.title,\n                    params: attr.params,\n                    raw: attr.rawValue\n                };\n\n                mksLinkService.getRoutes().then(function(items) {\n                    scope.items = items;\n                    if (scope.route.id) {\n                        selectRouteOption(scope.route.id);\n                    }\n                });\n\n                scope.modal = {\n                    id: 'modal-' + (new Date()).getTime(),\n                    loading: false\n                };\n\n                var paramsRequest = null;\n                var currentRoute = null;\n                var currentPage = 1;\n\n                function loadItems() {\n                    if (!scope.routeOption) {\n                        return;\n                    }\n\n                    if (paramsRequest && paramsRequest.abort) {\n                        paramsRequest.abort();\n                    }\n\n                    scope.modal.loading = true;\n\n                    (paramsRequest = mksLinkService.getParamsData({\n                        name: scope.routeOption.id,\n                        page: scope.modal.current_page || null,\n                        q: scope.modal.searchQuery || null\n                    })).then(function (data) {\n                        scope.modal.data = data;\n                        currentRoute = scope.routeOption.id;\n                        currentPage = data.pagination ? data.pagination.current_page : 1;\n                        scope.modal.current_page = currentPage;\n                    }).finally(function () {\n                        scope.modal.loading = false;\n                    });\n                }\n\n                scope.modal.open = function() {\n                    if (scope.routeOption) {\n                        if (scope.routeOption.extended) {\n                            if (currentRoute != scope.routeOption.id) {\n                                scope.modal.searchQuery = '';\n                                loadItems();\n                            }\n                        } else {\n                            if (typeof scope.routes[scope.routeOption.id] != 'undefined') {\n                                scope.modal.form = scope.routes[scope.routeOption.id].params;\n                            }\n                        }\n\n                        $('#' + scope.modal.id).modal('show');\n                    }\n                };\n\n                scope.modal.close = function() {\n                    $('#' + scope.modal.id).modal('hide');\n                };\n\n                scope.modal.select = function(item) {\n                    if (scope.modal.data.params && scope.routeOption) {\n                        var params = {};\n                        angular.forEach(scope.modal.data.params, function(p) {\n                            params[p] = item[p];\n                        });\n                        scope.routes[scope.routeOption.id] = {\n                            title: item.title,\n                            params: params\n                        };\n                        scope.modal.close();\n                    }\n                };\n\n                scope.modal.save = function() {\n                    if (scope.modal.form && scope.routeOption) {\n                        scope.routes[scope.routeOption.id] = {\n                            title: scope.paramsEncoded(scope.modal.form),\n                            params: scope.modal.form\n                        };\n                    }\n                    scope.modal.close();\n                };\n\n                scope.modal.prevPage = function(){\n                    if (typeof scope.modal.current_page != 'undefined' && scope.modal.current_page > 1) {\n                        scope.modal.current_page--;\n                    }\n                };\n\n                scope.modal.nextPage = function(){\n                    if (typeof scope.modal.current_page != 'undefined'\n                        && typeof scope.modal.data.pagination.last_page != 'undefined'\n                        && scope.modal.current_page < scope.modal.data.pagination.last_page) {\n                        scope.modal.current_page++;\n                    }\n                };\n\n                scope.$watch('modal.current_page', function(n, o) {\n                    if (n && n > 0 && n != currentPage) {\n                        loadItems();\n                    }\n                });\n\n                scope.modal.search = function(q) {\n                    if (scope.modal.current_page != 1) {\n                        scope.modal.current_page = 1;\n                    } else {\n                        loadItems();\n                    }\n                };\n\n                scope.paramsEncoded = function(params) {\n                    if (params && typeof params == 'object') {\n                        return angular.toJson(params);\n                    }\n                    return params;\n                };\n\n                scope.paramsVisible = function(data) {\n                    if (data) {\n                        if (data.title) {\n                            return data.title;\n                        }\n\n                        return scope.paramsEncoded(data.params);\n                    }\n                    return '';\n                }\n            }\n        };\n    }]);\n\n    app.directive('mksModalPaginator', ['$http', 'mksLinkService', function($http, mksLinkService, UrlBuilder) {\n        return {\n            restrict: 'E',\n            require: ['^', '@paginator'],\n            scope: {\n                paginator: '@paginator'\n            },\n            link: function(scope, elem, attr) {\n\n            }\n        }\n    }]);\n\n    app.directive('mksEditor', ['AppConfig', 'UrlBuilder', function (AppConfig, UrlBuilder) {\n        return {\n            restrict: 'A',\n            link: function (scope, elem, attrs) {\n                if (typeof CKEDITOR !== 'undefined') {\n                    var opt = {\n                        removePlugins: 'forms,audio,Audio,allmedias,base64image,markdown,googledocs',\n                        extraPlugins: 'wpmore',\n                        language: AppConfig.getLang('en'),\n                        filebrowserBrowseUrl: UrlBuilder.get('file-manager'),\n                        filebrowserImageBrowseUrl: UrlBuilder.get('file-manager?type=images'),\n                        filebrowserFlashBrowseUrl: UrlBuilder.get('file-manager?type=flash'),\n                        filebrowserWindowWidth: '85%'\n                    };\n                    if (attrs.mksEditor) {\n                        try {\n                            angular.extend(opt, scope.$eval(attrs.mksEditor));\n                        } catch (err) {\n                        }\n                    }\n                    CKEDITOR.replace(elem[0], opt);\n                }\n            }\n        };\n    }]);\n\n    app.directive('mksPageIframe', ['$window', function ($window) {\n        return {\n            restrict: 'A',\n            link: function (scope, elem, attrs) {\n                var $sidebar = angular.element('#sidebar');\n                if ($sidebar.length) {\n                    elem.height($sidebar.height());\n\n                    angular.element($window).on('resize.pageIframe', function() {\n                        elem.height($sidebar.height());\n                    });\n\n                    scope.$on('$destroy', function() {\n                        angular.element($window).off('resize.pageIframe');\n                    });\n                }\n\n                elem.parent().css({'padding-left': 0, 'padding-right': 0});\n            }\n        };\n    }]);\n\n    app.directive('mksSelect', [function () {\n        return {\n            restrict: 'A',\n            priority: -1,\n            link: function(scope, elem, attrs) {\n                var iconUrl = elem.data('langIcon');\n                if (iconUrl) {\n                    var formatResult = function(item) {\n                        if (!item.id) { return item.text; }\n                        var $item = $(\n                            '<span><img src=\"' + iconUrl + '/' + item.element.value.toLowerCase() + '\" class=\"img-flag\" /> ' + item.text + '</span>'\n                        );\n                        return $item;\n                    };\n\n                    elem.data('templateResult', formatResult);\n                    elem.data('templateSelection', formatResult);\n                }\n            }\n        };\n    }]);\n\n    app.component('mksImagesPicker', {\n        templateUrl: ['UrlBuilder', function(UrlBuilder) {\n            return UrlBuilder.get('templates/images-picker.html');\n        }],\n        bindings: {\n            url: '@',\n            items: '=?',\n            inputName: '@name',\n            pickMain: '@'\n        },\n        controller: ['$http', 'UrlBuilder', '$element', function($http, UrlBuilder, $element) {\n            var ctrl = this;\n            \n            this.$onInit = function () {\n                if (!this.inputName) {\n                    this.inputName = 'images';\n                }\n\n                if (!this.items) {\n                    this.items = [];\n\n                    if (this.url) {\n                        $http.get(this.url).then(function(r) {\n                            if (r.data) {\n                                ctrl.items = r.data;\n                            }\n                        });\n                    }\n                }\n\n                window.pickImageMultiple = function(urls) {\n                    ctrl.safeApply(function() {\n                        angular.forEach(urls, function(url) {\n                            ctrl.items.push({url: url});\n                        });\n                    });\n                };\n            };\n            \n            this.add = function () {\n                CKEDITOR.editor.prototype.popup(UrlBuilder.get('file-manager?type=images&multiple=1&callback=pickImageMultiple'));\n            };\n\n            this.delete = function (item) {\n                var index = this.items.indexOf(item);\n                if (index > -1) {\n                    this.items.splice(index, 1);\n                }\n            };\n\n            this.safeApply = function (fn) {\n                var scope = $element.scope();\n                var phase = scope.$$phase;\n                if (phase == '$apply' || phase == '$digest') {\n                    if (fn && (typeof (fn) === 'function')) {\n                        fn();\n                    }\n                } else {\n                    scope.$apply(fn);\n                }\n            };\n\n            this.itemsValue = function () {\n                return angular.toJson(this.items);\n            };\n\n            this.setMain = function (item) {\n                var index = this.items.indexOf(item);\n                if (index > -1) {\n                    for (var i=0; i < this.items.length; i++) {\n                        this.items[i].main = i == index;\n                    }\n                }\n            };\n        }]\n    });\n\n    app.run(['$rootScope', function($rootScope) {\n        //hide all modals when location changes\n        $rootScope.$on('$routeChangeStart', function(event, next, current) {\n            //$('.modal.in').modal('hide');\n            $('.modal.in').removeClass('in').hide();\n            $('.modal-backdrop').remove();\n        });\n    }]);\n\n})(window.angular);","(function(){\n    var app = angular.module('mks-admin-ext');\n\n    app.controller('WidgetRoutesCtrl', ['$scope', '$http', 'UrlBuilder', function($scope, $http, UrlBuilder) {\n\n        $scope.routes = [];\n\n        var self = this;\n\n        $scope.init = function(widgetId) {\n            $http.get(UrlBuilder.get('widget/routes' + (widgetId ? '/'+widgetId : ''))).then(function(r) {\n                $scope.routes = r.data;\n\n                if (!$scope.routes.length) {\n                    $scope.addChoice();\n                }\n            });\n        };\n\n        $scope.addChoice = function() {\n            $scope.routes.push({id:null});\n        };\n\n        $scope.removeChoice = function (item) {\n            var i = $scope.routes.indexOf(item);\n            if (i >= 0) {\n                $scope.routes.splice(i, 1);\n            }\n        };\n    }]);\n\n})(window.angular);\n"],"sourceRoot":"/source/"}